## 一、搭建起react项目

### 初始化项目：

```bash
npm install -g create-react-app 
create-react-app reactwallet
cd reactwallet
npm start
npm run eject
```

### 添加对less的支持：

```bash
npm i less less-loader -D
```

然后在./config/webpack.config.dev.js 和 ./config/webpack.config.prod.js中添加less文件的loader配置，可以从对css文件的loader配置中拷贝一下，稍加修改即可。

然后把原有的css文件改成less文件，并把文件中对于css的引用都更新成对于less的引用。

### 添加对antd-mobile的支持：

这里，需要改造对于babel-loader的配置，以适应对于antd-mobile的支持。

```bash
npm i antd-mobile --save
npm i babel-preset-env babel-preset-stage-2 babel-plugin-import -D
```

在根目录下新建.babelrc文件，内容为：

```
{
    "presets": [
        ["env", { "modules": false }], 
        "react",
        "stage-2"
    ],
    "plugins": [
        [
            "import",
            {
                "libraryName": "antd-mobile",
                "style": "css"
            }
        ]
    ]
}
```

在package.json中删除：

```
"babel": {
    "presets": [
        "react-app"
    ]
},
```

### 添加对TypeScript的支持

```bash
npm i classnames --save
npm i typescript ts-loader -D
```

在./config/webpack.config.dev.js中添加：

```
{
    test: /\.(tsx)$/,
    include: paths.appSrc,
    use: [
        {
            loader: require.resolve('babel-loader'),
            options: {
                // This is a feature of `babel-loader` for webpack (not Babel itself).
                // It enables caching results in ./node_modules/.cache/babel-loader/
                // directory for faster rebuilds.
                cacheDirectory: true,
            },
        },
        {
            loader: require.resolve('ts-loader'),
        }
    ]
},
```

在./config/webpack.config.prod.js中添加：

```
{
    test: /\.(tsx)$/,
    include: paths.appSrc,
    use: [
        {
            loader: require.resolve('babel-loader'),
            options: {
                compact: true,
            }
        },
        {
            loader: require.resolve('ts-loader'),
        }
    ],
},
```

在根目录下添加tsconfig.json，内容如下：

```
{
    "compilerOptions": {
        "strictNullChecks": true,
        "moduleResolution": "node",
        "jsx": "preserve",
        "noUnusedParameters": true,
        "noUnusedLocals": true,
        "allowSyntheticDefaultImports": true,
        "target": "es6",
        "types": [
            "classnames", 
            "react", 
            "react-dom", 
            "react-native"
        ]
    },
    "exclude": [
        "node_modules", 
        "lib",
        "es"
    ],
    "compileOnSave": false
}
```

安装上面配置到的一些types：

```bash
npm i @types/classnames  @types/react @types/react-dom @types/react-native --save
```

### 添加路由

npm i redux react-redux react-router react-router-dom history redux-saga react-router-redux redux-persist --save

redux-persist从4到5有较大变化，我们这里使用的是4，使用5的话会报错。这些模块的版本最好都保持跟原来的一样，不要去改它，以防因为版本不同而出错。

不过，新版kyber wallet已经使用了 "redux-persist": "^5.2.2"，所以应该也可以参照跟进了。

index.js中进行一系列配置，例如：

```
import React from 'react';
import { render } from 'react-dom';
import { Provider } from 'react-redux';
import { Route } from 'react-router';
import { Link, BrowserRouter, HashRouter } from 'react-router-dom';
import store from './store';
import './index.less';
import App from './App';
```

省去若干细节。


### 添加对装饰器如@connect这样语法的支持

```
npm i babel-plugin-transform-decorators-legacy -D
```

并在babel的plugins中添加：

["transform-decorators-legacy"]

### service is not defined no-undef

是eslint检查引起的，暂时先去掉检查

### 安装一批依赖

"es6-promise": "^4.1.0",
"ethereumjs-tx": "^1.3.1",
"ethereumjs-util": "^5.1.2",
"ethereumjs-wallet": "^0.6.0",
"fastclick": "^1.0.6",
"web3": "^0.19.1",
"react-select": "^@1.2.0",
"react-password-strength": "^2.0.0",

## 二、解读kyber wallet的老版代码

### web3.js 0.2x 版本如何进行一笔交易

```
export function sendTokenFromAccount(
  id, ethereum, account, sourceToken, sourceAmount,
  destAddress, nonce, gas, gasPrice, keystring,
  password, callback) {

  var txData = ethereum.sendTokenData(sourceToken, sourceAmount, destAddress)

  const txParams = {
    nonce: nonce,
    gasPrice: gasPrice,
    gasLimit: gas,
    to: sourceToken,
    value: 0,
    data: txData,
    // EIP 155 chainId - mainnet: 1, ropsten: 3
    chainId: 1337
  }
  const tx = sealTxByKeystore(txParams, keystring, password)

  store.dispatch(doTransaction(id, ethereum, tx, callback))
}
```

1、通过代币合约拿到要携带的数据data

`myContractInstance.myMethod.getData(...)`

```
sendTokenData(sourceToken, sourceAmount, destAddress) {
    var tokenContract = this.erc20Contract.at(sourceToken);
    return tokenContract.transfer.getData(destAddress, sourceAmount);
}
```

获取

`this.erc20Contract`是什么呢？它是一个合约对象。

```
this.rpc = new Web3(
    new Web3.providers.HttpProvider("http://localhost:8545")
);
this.erc20Contract = this.rpc.eth.contract(constants.ERC20); //创建一个合约对象
```

this.rpc是一个Web3实例，所以实际就是用了Web3.eth.contract(ABIArray)。传入的参数是一个ABI对象数组，里面包含了一到多个ABI对象。所谓ABI对象，就是描述合约的函数、事件的对象。

这里有个ERC20，它是什么呢？它是一个协议。市面上出现了大量的用ETH做的代币，它们都遵守ERC20协议。

2、获取到nonce, gasPrice, gasLimit, to, value, data, chainId等字段

nonce, gasPrice, gasLimit 分别怎么拿到，后两者是不是应该有个默认值？

3、基于上述字段，通过ethereumjs-tx模块创建交易，通过unlock方法获得私钥，然后用私钥对交易进行签名

```
export function sealTxByKeystore(params, keystore, password) {
  const tx = new EthereumTx(params) //EthereumTx是来自ethereumjs-tx模块的
  const privKey = unlock(keystore, password, true) //获得密钥
  tx.sign(privKey)
  return tx
}
```

其中，EthereumTx是来自ethereumjs-tx模块的，用于创建交易

### 如何获得某一个代币的余额

```
getTokenBalance(address, ownerAddr, callback) {
    var instance = this.erc20Contract.at(address); //在某地址上实例化一个代币合约，亦即使用一个在某个地址上已经存在的合约
    instance.balanceOf(ownerAddr, (error, result) => {
        if (error != null) {
            console.log(error);
        } else {
            callback(result);
        }
    });
}
```

要弄清楚这一点，首先我们需要搞清楚，代币对象是个什么结构？

#### 代币对象的结构

```
export default class Token {
  constructor(name, icon, symbol, address, owner, balance = 0) {
    this.name = name
    this.icon = icon
    this.symbol = symbol
    this.address = address
    this.ownerAddress = owner
    this.balance = balance
  }

  shallowClone() {
    return new Token(
      this.name, this.icon, this.symbol, this.address,
      this.ownerAddress, this.balance)
  }

  sync(ethereum, callback) {
    ethereum.getTokenBalance(
      this.address, this.ownerAddress, (balance) => {
        const tok = this.shallowClone()
        tok.balance = balance
        callback(tok)
    })
  }
}
```

这是代币的类。从中可以看出，代币有name, icon, symbol, address, owner, balance 等字段。其中，name, icon, symbol, address这四个字段都是固定的，它们分别是代币的名称、logo、符号（如以太币的符号是ETH）、地址。

而owner是代币持有者的地址，balance就是余额了。

**注意，上面的Token中的address是该代币币种合约的部署地址，所以它是唯一的。而ownerAddress是代币所有者的地址。**

#### 拿到代币合约实例

`var instance = this.erc20Contract.at(address); `在某地址上实例化一个代币合约，亦即使用一个在某个地址上已经存在的合约，这里的参数的address是代币的地址，就是刚刚我们提到的那个每一种代币的唯一、固定的地址。

拿到这个代币合约实例之后，我们就可以调用合约了。通过调用智能合约可以做很多的事情。比如：

获得代币交易时需要发送的data:

```
sendTokenData(sourceToken, sourceAmount, destAddress) {
    var tokenContract = this.erc20Contract.at(sourceToken);
    return tokenContract.transfer.getData(destAddress, sourceAmount);
}
```

### 如何创建智能合约源码、编译智能合约、部署一个智能合约(这部分内容待验证，好像是不太好用了)

实现智能合约的方式很多种，可以用truffle框架来实现，编译，部署。
这里介绍一种简单的使用nodejs来实现，编译，部署的方法。
创建一个nodejs项目，实现一个简单的智能合约。

```
mkdir sm && cd sm
npm init
mkdir contracts && cd contracts
```

#### 创建智能合约源码

下面我们新建一个智能合约文件：

```
vi BaseToken.sol
```

```
//BaseToken.sol
contract Token{
    address public owner;
    mapping (address => uint) public balances;
    event Sent(address from, address to, uint amount)

    //查看代币量
    function Token(){
        owner = msg.sender;
        balances[owner] = 100000000;
    }

    //传入 接收者地址 和 发送的代币量 进行转账
    function send(address receiver, uint amount){
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}
```

这个合约实现了一个造币和转币的逻辑。
我们的合约是运行在EVM(Ether虚拟机)上面的字节码，solidity是静态语言，需要通过编译器生成evm的字节码。

#### 编译智能合约

```
vi compile.js
```

```
// compile.js
const fs = require('fs')
const solc = require('solc') 

let source = fs.readFileSync("./contracts/BaseToken.sol", 'utf8') //读取合约源码文件
console.log('compiling contract...');
let compiledContract = solc.compile(source); //编译合约
console.log('done');

for (let contractName in compiledContract.contracts) {
    var bytecode = compiledContract.contracts[contractName].bytecode;
    var abi = JSON.parse(compiledContract.contracts[contractName].interface);
}
console.log(bytecode)
```

执行```node compile.js```,对BaseToken进行编译，生成字节码。编译之后，会有bytecode和interface，bytecode是智能合约字节码，interface可以JSON.parse出智能合约的abi数组。

#### 部署智能合约

web3中提供了一个部署合约的接口，使用如下。下面进行估算：

```
let gasEstimate = web3.eth.estimateGas({data: '0x' + bytecode});

console.log('gasEstimate: ' + gasEstimate)

let MyContract = web3.eth.contract(abi);

console.log('deploying contract...');


let myContractReturned = MyContract.new(
    [], 
    {
        from: address,
        data: '0x' + bytecode,
        gas: gasEstimate+50000
    }, 
    function(err, myContract){
        if(!err){
            if(!myContract.address){
                console.log(`myContract.transactionHash = ${myContract.transactionHash}`);
            }else{
                console.log(`myContract.address = ${myContract.address}`); // the contract address
                global.contractAddress = myContract.address;
            }
        }else{
            console.log(err);
        }
    }
);
```

`web3.eth.estimateGas()`节点中执行一个消息调用，或交易。但是不会合入区块链中。返回使用的gas量。

利用编译生成的abi和bytecode，创建一个合约对象，然后进行发布，等待着异步执行的方法输出合约地址contractAddress，这样就完成了部署。不过这种方式有一个问题，就是在发布合约时，你的私钥处于联网状态，出于安全策略，我们需要尽量避免私钥在联网状态。

以太坊上部署合约是向空地址发送一个附有字节码的签名交易，其中发送者就是这个合约的拥有者。因此我们只需要将合约构建成一笔交易，我们在无网状态下对这笔交易进行签名，然后将签名发送到以太坊网络中。这样能够降低我们私钥被泄漏的风险。

对合约的签名方法如下：

```
var Tx = require('ethereumjs-tx')
const rawTx = {
    nonce: '0x6', //这个是你的地址的交易次数+1，0开始
    gasPrice: '0x12a05f200',
    gasLimit: '0x493e0',
    data: bytecode,
    from: address,
    to: ""
};
const tx = new Tx(rawTx);
tx.sign(privateKey);
const serializedTx = tx.serialize();
console.log(serializedTx.toString('hex'));
```

**以上对一个合约签名，这里需要注意的问题是，to的地址需要是空地址。**

完成签名之后，我们把这笔交易发送出去就好，最简单的方法就是使用etherscan的发送Tx的方式，一旦发送完成，部署完成，就可以看到合约地址。

## 三、从web3.js 0.x 升级到web3.js 1.0beta

### 1、改变库

```bash
npm i web3@1.0.0-beta.28 bignumber.js --save
```

### 2、修改智能合约对象的生成

this.rpc.eth.contract(ABIarray)

改成

new this.rpc.eth.Contract(ABIarray)

### 3、修改智能合约的实例化

将

`this.rpc.eth.contract(ABIarray).at(contractAddress)`

改成

`new this.rpc.eth.Contract(ABIarray, contractAddress);`

将

`this.erc20Contract.at(contractAddress)`

改成

```js
var tokenContract = this.erc20Contract;
tokenContract.options.address = contractAddress;
```


### 4、eth.filter已经废弃了，所以this.rpc.eth.filter的监听需要改成用setInterval实现。

### 5、调用智能合约的方法的方式变了

```this.networkContract.getRate(source, dest, reserve, callback) {...}```

改成

```this.networkContract.methods.getRate(source, dest, reserve).call().then(...).catch(...)```

### 6、最坑的一点，升级之后，智能合约output解析出错：

Error: Couldn't decode uint256 from ABI: 0x

在此环节中value==''，导致抛出错误，至今不知如何修改。

https://github.com/jdkanani/web3.js/commit/085a2962dca6cc3a1fc1bcf0a31c946a591708f1


智能合约的调用的实例化方式变了（从给at传参的方式变成了设置options.address），调用智能合约内函数的方法也变了（变成了.methods）,getData也变了等等，可参见下面这个例子。

旧的：

```
sendTokenData(sourceToken, sourceAmount, destAddress) {
    var tokenContract = this.erc20Contract.at(sourceToken);
    return tokenContract.transfer.getData(destAddress, sourceAmount);
}
```

新的：

```
sendTokenData(sourceToken, sourceAmount, destAddress) {
    var tokenContract = this.erc20Contract;
    tokenContract.options.address = sourceToken;
    return tokenContract.methods.transfer(destAddress, sourceAmount).encodeABI();
}
```

## 四、读kyber wallet新版的源码

### 修正一个导致在本机运行时，不能导入账户的错误

web3-eth库的index.js文件中，有一个错误，config一直没能添加进来，所以手动地加入：

```
var helpers = require('web3-core-helpers');

//下面的这几行是自己添加的
helpers.config = {
    defaultBlock: 'latest',
    defaultAccount: null
}
console.log('自己修改helpers，添加了config：', helpers);
```

同时需要修改webpack.config.js中的配置，以便于能够将上面这个修改打包进去。

```
exclude: /node_modules\/(?!(web3-eth)\/).*/,
```

### docs 文件夹

无关紧要

### env 文件夹

主要是用通过 process.env.npm_config_chain 这个环境变量来切换不同的网络，默认是 kovan，还有 ropsten 和 mainnet。与之对应的，package.json 中有--env.chain=ropsten之类的配置选项。

这个env文件夹里面有几个.json 文件用来配置不同环境下的配置项，包括连接的地址，支持哪些代币等等。

并通过一个 js 文件将配置作为一个对象进行了抛出。

```json
{
    "connections": {
        "http": [
            "https://ropsten.infura.io/DtzEYY0Km2BA3YwyJcBG",
            "https://ropsten.infura.io/0BRKxQ0SFvAxGL72cbXi",
            "https://ropsten.infura.io/Ho4cy66JFfTvvAVlXvii",
            "https://ropsten.infura.io/aFvzEJSCQtTUJJ0Ec0mW",
            "https://ropsten.infura.io/uF2YCXrIz7yUFEXd2yo0",
            "https://ropsten.infura.io/NhLyl78p5UrUgBN5GSty"
        ],
        "ws": "wss://ropsten.kyber.network/ws/"
    },
    "history_endpoint": "https://cache.kyber.network",
    "api_usd": "https://api.coinmarketcap.com",
    "tokens": {
        "ETH": {
            "name": "Ethereum",
            "symbol": "ETH",
            "icon": "eth.svg",
            "address": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            "decimal": 18,
            "usd_id": "ethereum"
        },
        "KNC": {
            "name": "KyberNetwork",
            "symbol": "KNC",
            "icon": "knc.svg",
            "address": "0xa59826bfd12c6cddff70137a5f3e29b75215c531",
            "decimal": 18,
            "usd_id": "kyber-network"
        },
        "OMG": {
            "name": "OmiseGO",
            "symbol": "OMG",
            "icon": "omg.svg",
            "address": "0x98541419c0f9873acf6bf449cb7246f9df600d2c",
            "decimal": 18,
            "usd_id": "omisego"
        },
        "DGD": {
            "name": "DigixDAO",
            "symbol": "DGD",
            "icon": "dgd.svg",
            "address": "0xe8c213a416646b5dfc04845d1b3e471b35599722",
            "decimal": 9,
            "usd_id": "digixdao"
        },
        "CVC": {
            "name": "Civic",
            "symbol": "CVC",
            "icon": "cvc.svg",
            "address": "0x5313256342e3b2a12188b91eee310f8311b8aa73",
            "decimal": 8,
            "usd_id": "civic"
        },
        "FUN": {
            "name": "FunFair",
            "symbol": "FUN",
            "icon": "fun.svg",
            "address": "0xf96a8f7cd011a3cf2f2c8f5fdf8aaf0471ec3302",
            "decimal": 8,
            "usd_id": "funfair"
        },
        "MCO": {
            "name": "Monaco",
            "symbol": "MCO",
            "icon": "mco.svg",
            "address": "0xec8530552d545aa50668af7d75a96d9359d7388a",
            "decimal": 8,
            "usd_id": "monaco"
        },
        "GNT": {
            "name": "Golem",
            "symbol": "GNT",
            "icon": "gnt.svg",
            "address": "0x4d46106343242999b7617e6c1a8f6d4927831582",
            "decimal": 18,
            "usd_id": "golem-network-tokens"
        },
        "ADX": {
            "name": "AdEx",
            "symbol": "ADX",
            "icon": "adx.svg",
            "address": "0xf0de273c82a7eddd6057d963b848cd21309364bf",
            "decimal": 4,
            "usd_id": "adx-net"
        },
        "PAY": {
            "name": "TenX",
            "symbol": "PAY",
            "icon": "pay.svg",
            "address": "0xa8f3612baea3998fee82673506189dc277eb8973",
            "decimal": 18,
            "usd_id": "tenx"
        },
        "BAT": {
            "name": "BasicAttention",
            "symbol": "BAT",
            "icon": "bat.svg",
            "address": "0xfe35c93a01af76dbe1116f13dd903578f340ab7d",
            "decimal": 18,
            "usd_id": "basic-attention-token"
        },
        "EOS": {
            "name": "Eos",
            "symbol": "EOS",
            "icon": "eos.svg",
            "address": "0x7d7fd73fede850a0d3f044af79ba83490830ae4b",
            "decimal": 18,
            "usd_id": "eos"
        },
        "LINK": {
            "name": "ChainLink",
            "symbol": "LINK",
            "icon": "link.svg",
            "address": "0xfab56a845dbb07f6ffdadf225713de8617e37d5c",
            "decimal": 18,
            "usd_id": "chainlink"
        }
    },
    "ethScanUrl": "https://ropsten.etherscan.io/",
    "bank": "0xcbae93b11b0a7a944649f26f17ab5566a1526f6f",
    "reserve": "0x488b362e51a53e969cb28f42eadc41411f20a835",
    "pricing": "0x6dcf29f5dc0f207e6d850d9436e35281079bc063",
    "network": "0xe801403a9b8dae494f9088a4687c1c139fae2fe4",
    "wrapper": "0x54556ac5afbd73b6a9d1c3d2d679477dd33ea81f",
    "trade_topic":
        "0xec0d3e799aa270a144d7e3be084ccfc657450e33ecea1b1a4154c95cedaae5c3",
    "endpoint": "https://ropsten.infura.io/DtzEYY0Km2BA3YwyJcBG",
    "averageBlockTime": 6000,
    "networkId": 3,
    "chainName": "Ropsten",
    "faucet": "https://faucet.kyber.network/",
    "server_logs": {
        "url": "ropsten.etherscan.io",
        "api_key": "D8YAEQ3V4THAPDA9YSB1YGA1QY9KAMHY6M"
    }
}
```

疑问：

network、wrapper分别是什么？如果 network 是网络地址的话，wrapper 又有什么用呢？从使用上看，两者都是合约地址。

```js
initContract() {
    this.erc20Contract = new this.rpc.eth.Contract(constants.ERC20)
    this.networkAddress = BLOCKCHAIN_INFO.network
    this.wrapperAddress = BLOCKCHAIN_INFO.wrapper
    this.networkContract = new this.rpc.eth.Contract(constants.KYBER_NETWORK, this.networkAddress)
    this.wrapperContract = new this.rpc.eth.Contract(constants.KYBER_WRAPPER, this.wrapperAddress)
}
```

### lang 目录下主要是所支持的各个语言包（.json 文件）

默认是英语。

抛出了：

`module.exports = { supportLanguage, defaultLanguage, loadAll, defaultAndActive, otherLang }`

语言包的格式如下：

```json
{
    "pack": "cn",
    "pack_icon": "cn.svg",
    "pack_label": "中文",
    "pack_active": true,
    "layout": {
        "info": "信息",
        "terms_of_service": "服务条款",
        "privacy_policies": "隐私政策"
    },

    "transaction_list": {
        "transaction_history": "最近交易"
    },

    "address": {
        "address": "地址",
        "import_address": "导入地址",
        "my_balance": "余额",
        "total": "估值",
        "hide_zero_balance": "隐藏小额资产"
    },
    "transaction": {
        "exchange": "交易",
        "exchange_from": "从",
        "exchange_to": "到",

        "transfer": "转移",
        "transfer_to_address": "转移到地址",
        "amount": "数量",
        "select_token": "选择代币",

        "advanced": "高级选项",
        "transaction_fee": "交易费",

        "address_balance": "地址余额",
        "balance": "余额",
        "password_needed_exchange": "每笔交易都需要密码",

        "password_needed_transfer": "每笔转移都需要密码",
        "next": "下一个",
        "exit": "退出",
        "back": "主页",
        "new_tx": "新的转移",
        "new_ex": "新的交易",
        "done": "完成!",
        "failed": "失败!",
        "broadcasted": "交易上链完成!",
        "broadcasting": "交易上链中!",
        "success_ex_msg": "成功地将 ${source} 交易为 ${dest} 了",
        "success_tx_msg": "成功地将 ${token} 转移至 ${address}",
        "copy_tx": "拷贝交易哈希",
        "analyze_error": "失败原因",
        "copied": "拷贝成功",
        "analyze": "显示原因",

        "broadcast": "交易上链",
        "transaction": "交易",
        "broadcasted_title": "将您的交易广播至区块链",
        "close_browser_or_make_new_exchange":
            "您现在可以关闭浏览器窗口或进行另一币交易",
        "close_browser_or_make_new_transfer":
            "您现在可以关闭浏览器窗口或进行另一币转移",
        "broadcasting_blockchain": "您的交易正在被上链至区块链",
        "cound_not_broadcast": "无法将您的交易上链至区块链",
        "current_address_balance": "当前地址余额",
        "transaction_error": "交易错误",
        "waiting_transaction": "您的交易正在等待被挖掘",

        "about_to_exchange": "您将开始交易",
        "about_to_transfer": "您将开始转移",
        "processing": "处理中",
        "gas_limit": "燃料限额",
        "gas_price": "燃料价格",
        "for": "换至",
        "to": "至",
        "best_rate": "最小价格",
        "token_amount": "代币／数量",

        "transfer_tooltip": "转移以太或代币至其它地址",
        "transaction_gasprice_50":
            "更高的燃料价格，更快的交易速度。最高燃料价格：50 Gwei",
        "transaction_gasprice": "更高的燃料价格，更快的交易速度",
        "best_rate_tooltip": "市场波动时，更低的价格可以带来更好的成功率",
        "terms_and_conditions":
            "<span>条款和 <br  class='show-for-small-only'>条件</span>",

        "error_tx_log": "空的日志",
        "error_tx_contract": "警告！合约执行过程中发生了错误",
        "no_pedding_tx": "没有待处理的交易",
        "rate_info":
            "价格也许会在结算过程中发生变化。<br> 您可以点击\"高级选项\"来显示您的最低价格。"
    },

    "modal": {
        "enter_password": "输入密码",
        "confirm": "确认",
        "import": "导入",
        "enter_password_placeholder": "输入钱包密码进行确认",
        "select_hd_path": "选择硬盘派生路径",
        "select_trezor_address": "选择TREZOR地址",
        "select_ledger_address": "选择LEDGER地址",
        "select_address": "选择您想要使用的地址",
        "previous_addresses": "以前的地址",
        "more_addresses": "更多地址",
        "custom_path": "您的自定义路径",
        "view_on_etherscan": "在Etherscan上查看",
        "press_confirm_if_really_want": "请按确认以继续",
        "waiting_for_confirmation": "正在等待您钱包的确认信息",
        "confirm_exchange_title": "交易确认",
        "confirm_transfer_title": "转移确认",

        "select_your_language": "选择你的语言",
        "select_source_token": "选择原始代币",
        "select_dest_token": "选择终点代币",
        "select_trasfer_from_token": "选择 \"TRANSFER FROM\" 代币",

        "approve_exchange":
            "您需要获取Kyber钱包的许可才能在当前地址与<strong>${ token }</strong>交互",
        "eth_token_exchange": "ETH代币交易",
        "approve": "批准"
    },

    "error": {
        "select_same_token": "无法和同种代币进行交易",
        "select_token_token": "这个代币交易对目前还不支持",
        "source_amount_too_high": "原始数量过高",
        "source_amount_too_high_cap":
            "原始数量超过了你的额度。你的额度是${ cap }ETH",
        "source_amount_too_small": "原始数量过低",
        "source_amount_rate_error": "当前无法交易",
        "source_amount_too_high_for_reserve":
            "原始数量过高 （交易对目前还不支持）",
        "source_amount_is_not_number": "原始数量不是一个数字",

        "dest_address": "这不是一个地址",
        "amount_transfer_too_hign": "数量过高",
        "amount_must_be_number": "数量必须是一个数字",

        "error_occurred": "发生错误",
        "cannot_connect_metamask": "无法获取Metamask账户",
        "cannot_connect_trezor": "无法连接至Trezor",
        "cannot_connect_ledger": "无法连接至Ledger",
        "invalid_private_key": "无效的密钥",
        "no_balance": "您的地址上没有我们支持的代币。请导入其它的地址。",
        "clear_data_timeout":
            "由于您的会话超时，我们清除了您的数据 ${time} 分钟",
        "minutes": " 分钟",
        "time_out": "超时",
        "network_error": "目前无法连接到区块链。请稍后再尝试。",
        "term_error": "您必须先同意服务条款！",

        "path_not_support_by_trezor": "Trezor不支持这个路径",
        "check_right_application_selected": "检查是否选择了正确的应用",
        "network_not_match":
            "Metamask需要连接到${expectedName}网络，而您现在连接的是${currentName}",
        "network_not_match_unknow": "Metamask需要连接到${expectedName}",
        "not_supported": "不支持",
        "metamask_not_install":
            "无法连接至metamask。请确认您已经安装了metamask。",

        "gas_price_not_number": "燃料价格不是数字",
        "rate_not_number": "交易价格不是数字",
        "gas_price_limit": "燃料价格必须小于 ${maxGas} Gwei",
        "passphrase_error": "秘钥派生失败",
        "gas_price_exceeded_limit": "燃料价格超过了最高限制。t",
        "issue_token_ether":
            "交易失败，由于发送eth的同时还试图用该eth与其它代币交易。",
        "issue_allowance": "交易失败，由于许可数量低于srcAmount",
        "issue_balance": "交易失败，由于代币余额低于scrAmount",
        "issue_ether_amount": "交易失败，由于用户没有发送准确的eth数量",
        "issue_user_cap": "交易失败，由于原始数量超过了用户限额。",
        "min_rate_too_high": "你设置的最交易低价格太高了！"
    },

    "import": {
        "from_metamask": "连接至<br>Metatmask",
        "from_keystore": "选择或拖动<br />您的密钥库",
        "from_trezor": "从<br />Trezor导入",
        "from_ledger": "从<br />Ledger导入",
        "from_private_key": "请输入您的<br />密钥",
        "from_private_key_input_title": "请输入您的密钥",
        "from_private_key_input_title_placehoder": "请输入您的密钥"
    },

    "info": {
        "title": "Kyber测试网络",
        "version": "版本",
        "chain": "链",
        "node_endpoint": "节点端",
        "reserve_address": "储蓄库合约地址",
        "network_address": "网络合约地址",
        "kyber_homepage": "Kyber主页",
        "get_free_kovan": "获取免费的",
        "warning":
            "请不要发送以太或代币到以上的任何地址.<br></br>他们都是测试网络的地址！",
        "here": "这里"
    },

    "footer": {
        "info": "信息",
        "language": "语音"
    },

    "history": {
        "second_ago": "秒之前",
        "minutes_ago": "分钟之前",
        "hours_ago": "小时之前",
        "days_ago": "天之前",
        "months_ago": "月之前",
        "years_ago": "年之前",
        "date": "日期",
        "rate": "汇率",
        "description": "描述",
        "amount": "数量"
    },

    "terms": {
        "title": "Kyber钱包 - 使用条款",
        "content":
            "Kyber测试网络钱包提供了一个让大家能够实验和了解我们的交易和支付的服务平台。 目前的版本可能不安全。 使用它可能会导致资金损失，并可能危及用户的隐私。 用户对使用Kyber测试网络钱包的任何结果承担全部责任。",
        "use_testnet": "请务必使用测试网络的钱包！！！",
        "use_real": "请千万不要使用真实的以太坊账户！！！",
        "accept": "Accept"
    },

    "landing_page": {
        "title": "以太坊代币的去中心化交易",
        "trustless": "无需信赖",
        "instant": "迅速",
        "liquid": "流动性",
        "compatible": "兼容",
        "get_started": "开始"
    },

    "product_feedback": "产品反馈",
    "help": "帮助"
}
```

### server 目录，主要功能是本机后台接口服务

这个目录有一个 eth 目录，这个目录主要是用来与以太坊进行连接和交互用的。

这里面，baseProvider、httpProvider、wsProvider三个文件是用来封装出两个provider组件，一个是http服务的，一个是ws服务的。而baseProvider则是二者的共同基础，提供了一个BaseEthereumProvider类，类中提供了如下一些方法：

initContract方法 将三个合约对象、两个合约地址挂载到this上；

version方法 返回当前所用的web3.js的版本；

getLatestBlockFromEtherScan、getLatestBlockFromNode getLatestBlockFromEtherScan先从某个服务端API中去拿最新区块的区块number序号（估计是考虑缓存的关系，但是为什么要缓存呢，是什么原因导致不够快需要缓存？），拿不到的情况下再调用getLatestBlockFromNode去以太坊节点上拿。返回的是个数字。

疑问：

getRate、getAllRate、getAllRatesFromEtherscan、getAllRatesFromBlockchain、getAllRateFromNode、getAllRateUSD、getRateUSD、getLogExchange、getLogExchangeFromNode

等方法，暂时没弄清楚其细节。具体是在什么地方用到的还不是很清楚？

这些接口没有的话也是可以的，直接用testnet上的就好了，或者直接由 mock 数据的平台进行数据 mock。咨询过相关开发人员，说其实这些node.js开发的这些本地接口是废弃掉了，因为不稳定，所以改成了go的接口，不过不开源。

执行`npm run server`实际执行的是 server 目录下的 server_http.js 文件（package.json 中有配置）。

```js
var express = require("express");
var cors = require("cors");
var app = express();
app.use(cors());
```

上述代码用于允许任何域名跨域访问。cors 是一个可以进行各种参数配置，解决跨域问题的模块。

https://www.npmjs.com/package/cors

在该目录下保存着一个日志文件，error.log。采用了 simple-node-logger 模块来打日志。https://www.npmjs.com/package/simple-node-logger

在 server_http.js 中，通过 sqlitePersist.js 中创建的 SqlitePersist 类提供的方法先是初始化了各个表，然后提供了一系列接口服务，/getRate、/getHistory、/getHistoryTwoColumn、/getHistoryOneColumn、/countHistory、/getLatestBlock、/getRateUSD、/getLanguagePack 等接口服务。这些接口服务都是放在https://cache.kyber.network/下的。是因为web3.js无法实现这些功能呢，还是为了速度更快？

这些接口背后都是在 sqlitePersist.js 中创建的 SqlitePersist 类通过直接操作 sqlite 数据库而实现的。接口的返回的数据格式如下：

/getRate

```json
[
    {
        "id": 1,
        "source": "ETH",
        "dest": "ETH",
        "rate": "0",
        "minRate": "0",
        "expBlock": "0",
        "balance": "0"
    },
    {
        "id": 2,
        "source": "ETH",
        "dest": "ETH",
        "rate": "0",
        "minRate": "0",
        "expBlock": "0",
        "balance": "0"
    }
]
```

/getUSD 各种代币兑美元的价格

```json
[
    {
        "symbol": "ETH",
        "price_usd": "1076.22"
    },
    {
        "symbol": "KNC",
        "price_usd": "3.98993"
    },
    {
        "symbol": "OMG",
        "price_usd": "17.4549"
    },
    {
        "symbol": "DGD",
        "price_usd": "189.409"
    },
    {
        "symbol": "CVC",
        "price_usd": "0.751849"
    },
    {
        "symbol": "FUN",
        "price_usd": "0.110938"
    },
    {
        "symbol": "MCO",
        "price_usd": "13.2256"
    },
    {
        "symbol": "GNT",
        "price_usd": "0.63423"
    },
    {
        "symbol": "ADX",
        "price_usd": "2.0149"
    },
    {
        "symbol": "PAY",
        "price_usd": "2.50536"
    },
    {
        "symbol": "BAT",
        "price_usd": "0.563943"
    },
    {
        "symbol": "EOS",
        "price_usd": "14.6735"
    },
    {
        "symbol": "LINK",
        "price_usd": "0.94457"
    }
]
```

/getHistoryTwoColumn

```json
{
    "eth": [
        {
            "id": 1035,
            "actualDestAmount": "72435007953030924402",
            "actualSrcAmount": "1000000000000000000",
            "dest": "0x7d7fd73fede850a0d3f044af79ba83490830ae4b",
            "source": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            "sender": null,
            "blockNumber": 2501159,
            "txHash":
                "0x01ca789571c4bb6746a72cf0167093277f2e800af06b5d77ea5e41d5c1d9a2b3",
            "timestamp": 1516606600,
            "status": "mined"
        },
        {
            "id": 1034,
            "actualDestAmount": "122174031265158964378",
            "actualSrcAmount": "2000000000000000000",
            "dest": "0x98541419c0f9873acf6bf449cb7246f9df600d2c",
            "source": "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",
            "sender": null,
            "blockNumber": 2501146,
            "txHash":
                "0x91987292f81b1ea8870b6d0445eaa033c8ba81ea4097f24faca08f25668a4b53",
            "timestamp": 1516606435,
            "status": "mined"
        }
    ]
}
```

/getLatestBlock
2501287

/countHistory
1036

/getLanguagePack
目前未实现，大概本来是考虑用来进行语言包方面处理的


### 解读baseProvider，其中封装了很多的基础操作方法

#### 获取 gasPrice

```js
getGasPrice() {
    return new Promise((resolve, reject) => {
      this.rpc.eth.getGasPrice()
        .then((result) => {
          resolve(result)
        })
        .catch((err) => {
          reject(err)
        })
    })
}
```

#### 判断是否连接上节点

因为 web3.js 好像没有提供直接的 API，所以需要自行处理。我们可以通过获取最近一个块，看能不能获取到来实现节点连接成功与否的判断。

```js
isConnectNode() {
    return new Promise((resolve, reject) => {
      this.rpc.eth.getBlock("latest", false).then((block) => {
        if (block != null) {
          resolve(true)
        } else {
          resolve(false)
        }
      }).catch((errr) => {
        resolve(false)
      })
    })
}
```

#### 获取ETH的余额

```js
getBalance(address) {
    return new Promise((resolve, reject) => {
      this.rpc.eth.getBalance(address)
        .then((balance) => {
          if (balance != null) {
            resolve(balance)
          }
        })
        .catch((err) => {
          console.log(err)
          reject(err)
        })
    })
}
```

#### 获取所有代币的余额

这里针对ETH和其它代币需要分别进行处理。

获取ETH的余额上面实现了；

而获取其它代币的余额是需要调用erc20Contract的balanceOf方法来处理的：

先是通过`var data = instance.methods.balanceOf(ownerAddr).encodeABI()`获得消息调用所需的数据。

然后通过web3.eth.call方法执行消息调用，`web3.eth.call`执行的消息调用只会在节点的VM中直接执行，但不会被挖到区块链上去。

`web3.eth.call`的用法如下：

```
web3.eth.call({
    to: "0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe", // contract address
    data: "0xc6888fa10000000000000000000000000000000000000000000000000000000000000003"
})
.then(console.log);
```

最后通过`web3.eth.abi.decodeParameter(type, hexString);`将ABI编码参数解码成其JavaScript对象，从而从中拿到我们需要的值。

解码 ABI encoded parameters的使用方法如下：

```
web3.eth.abi.decodeParameters(typesArray, hexString);
```

```
web3.eth.abi.decodeParameters(['string', 'uint256'], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000');
> Result { '0': 'Hello!%!', '1': '234' }
```

这种调用智能合约拿数据、通过`web3.eth.call`进行消息调用，通过三步走的方法非常常用。

```
getAllBalancesToken(address, tokens) {
    var promises = Object.keys(tokens).map(index => {
      var token = tokens[index]
      if (token.symbol === 'ETH') {
        return new Promise((resolve, reject) => {
          this.getBalance(address).then(result => {
            resolve({
              symbol: 'ETH',
              balance: result
            })
          }).catch(err => {
            reject(new Error("Cannot get balance of ETH"))
          })
        })

      } else {
        return new Promise((resolve, reject) => {
          this.getTokenBalance(token.address, address).then(result => {
            resolve({
              symbol: token.symbol,
              balance: result
            })
          }).catch(err => {
            reject(new Error("Cannot get balance of " + token.symbol))
          })
        })
      }
    })
    return Promise.all(promises)
}

getTokenBalance(address, ownerAddr, blockno) {
    var instance = this.erc20Contract
    instance.options.address = address

    var data = instance.methods.balanceOf(ownerAddr).encodeABI()

    return new Promise((resolve, reject) => {
      this.rpc.eth.call({
        to: address,
        data: data
      }, blockno ? blockno : this.rpc.eth.defaultBlock)
        .then(result => {
          var balance = this.rpc.eth.abi.decodeParameters(['uint256'], result)
          resolve(balance[0])
        }).catch((err) => {
          // console.log(err)
          reject(err)
        })
	})
}
```

#### 获取最近一个区块的区块序号

```js
function getLatestBlockFromNode(){
    new Promise(resolve, reject){
        web3.eth.getBlock("latest", false)
        .then(result => {
            resolve(result.number)
        })
        .catch(err => {
            reject(err)
        })
    }
}
```

### 更多对于智能合约的操控

#### 创建智能合约对象

`new web3.eth.Contract(jsonInterface[, address][, options])`

第一个参数是智能合约中的abi对象，第二个参数是地址（可选，也可以后续通过.options.address指定），第三个参数，可选项，是携带的一些options参数

```
new web3.eth.Contract(constants.KYBER_NETWORK, this.networkAddress)
```

#### 调用“常量”方法并在EVM中执行其智能合约方法（这不会发送交易，这种方式也不能改变智能合约状态。）

`myContract.methods.myMethod([param1[, param2[, ...]]]).call(options[, callback])`

```
getRate(source, dest, quantity) {
    return new Promise((resolve, rejected) => {
      this.networkContract.methods.getExpectedRate(source, dest, quantity).call().then((result) => {
        if (result != null) {
          resolve(result)
        }
      }).catch(e =>{
        rejected(e)
      })
    })
}
```

这个就调用了KYBER_NETWORK的getExpectedRate方法，传入了三个参数source, dest, quantity，这三个参数正好是KYBER_NETWORK的智能合约ABI对象数组中name: "getExpectedRate"所对应的inputs(如下)：

```js
{
    constant: true,
    inputs: [
        { name: "source", type: "address" },
        { name: "dest", type: "address" },
        { name: "srcQuantity", type: "uint256" }
    ],
    name: "getExpectedRate",
    outputs: [
        { name: "expectedPrice", type: "uint256" },
        { name: "slippagePrice", type: "uint256" }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
}
```

#### 怎么获得合约的某方法的编码过的ABI字节码，可以用在发送交易, 调用方法, 或作为参数传给另一个智能合约方法

`myContract.methods.myMethod([param1[, param2[, ...]]]).encodeABI()`

```js
var dataAbi = this.wrapperContract.methods.getExpectedRates(this.networkAddress, sources, dests, quantity).encodeABI()
var options = {
    host: serverPoint,
    path: `/api?module=proxy&action=eth_call&to=${this.wrapperAddress}&data=${dataAbi}&tag=latest&apikey=${api}`
}
```

### 对于新版kyber wallet交易流程的剖析

点击的时候会触发this.processTx。

```js
processTx = (password) => {
    try {
      if (this.props.account.type !== "keystore") {
        password = ''
      }
      const params = this.formParams()
      // sending by wei
      var account = this.props.account
      var ethereum = this.props.ethereum
      var formId = "transfer"
      var data = this.recap()
      this.props.dispatch(transferActions.processTransfer(formId, ethereum, account.address,
        params.token, params.amount,
        params.destAddress, params.nonce, params.gas,
        params.gasPrice, account.keystring, account.type, password, account, data, this.props.keyService, params.balanceData)
      )
    } catch (e) {
      console.log(e)
      	this.props.dispatch(transferActions.throwPassphraseError(this.props.translate("error.passphrase_error")))
    }
}
```

actions/transferActions.js中：

```js
export function processTransfer(formId, ethereum, address,
  token, amount,
  destAddress, nonce, gas,
  gasPrice, keystring, type, password, account, data, keyService, balanceData) {
  return {
    type: "TRANSFER.PROCESS_TRANSFER",
    payload: {
      formId, ethereum, address,
      token, amount,
      destAddress, nonce, gas,
      gasPrice, keystring, type, password, account, data, keyService, balanceData
    }
  }
}
```

sagas/transferActions.js中：

```js
export function* watchTransfer() {
  yield takeEvery("TRANSFER.TX_BROADCAST_PENDING", broadCastTx)
  yield takeEvery("TRANSFER.PROCESS_TRANSFER", processTransfer)
}
```

```js
export function* processTransfer(action) {
  const { formId, ethereum, address,
    token, amount,
    destAddress, nonce, gas,
    gasPrice, keystring, type, password, account, data, keyService, balanceData } = action.payload
  var callService = token == constants.ETHER_ADDRESS ? "sendEtherFromAccount" : "sendTokenFromAccount"
  switch (type) {
    case "keystore":
      yield call(transferKeystore, action, callService)
      break
    case "privateKey":
    case "trezor":
    case "ledger":
      yield call(transferColdWallet, action, callService)
      break
    case "metamask":
      yield call(transferMetamask, action, callService)
      break
  }
}
```

```js
function* transferKeystore(action, callService) {
  const { formId, ethereum, address,
    token, amount,
    destAddress, nonce, gas,
    gasPrice, keystring, type, password, account, data, keyService, balanceData } = action.payload
  try {
    var rawTx = yield call(keyService.callSignTransaction, callService, formId, ethereum, address,
      token, amount,
      destAddress, nonce, gas,
      gasPrice, keystring, type, password)
  } catch (e) {
    yield put(actions.throwPassphraseError(e.message))
    return
  }
  try {
    yield put(actions.prePareBroadcast(balanceData))
    const hash = yield call(ethereum.call("sendRawTransaction"), rawTx, ethereum)
    yield call(runAfterBroadcastTx, ethereum, rawTx, hash, account, data)
  } catch (e) {
    yield call(doTransactionFail, ethereum, account, e.message)
  }
}
```

services/keys/keystore.js中：
```js
import * as keyService from "./baseKey"
import EthereumTx from "ethereumjs-tx"
import { unlock } from "../../utils/keys"

export default class KeyStore {
  callSignTransaction = (funcName, ...args) =>{
    const { txParams, keystring, password } = keyService[funcName](...args)
    const tx = this.sealTx(txParams, keystring, password)
    return new Promise((resolve) => {
      resolve(tx)
    })
  }

  sealTx = (txParams, keystring, password) => {
    const tx = new EthereumTx(txParams)
    const privKey = unlock(keystring, password, true)
    tx.sign(privKey)
    return tx
  }
}
```

services/keys/baseKey.js中：

```js
//发送以太币
export const sendEtherFromAccount = (
  id, ethereum, account, sourceToken, sourceAmount,
  destAddress, nonce, gas, gasPrice, keystring, accountType,
  password) => {

  const txParams = {
    from:account,
    nonce: nonce,
    gasPrice: gasPrice,
    gasLimit: gas,
    to: destAddress,
    value: sourceAmount,
    // EIP 155 chainId - mainnet: 1, ropsten: 3
    chainId: BLOCKCHAIN_INFO.networkId
  }

  return { txParams, keystring, password }
}

//发送其他代币
export const sendTokenFromAccount = (
  id, ethereum, account, sourceToken, sourceAmount,
  destAddress, nonce, gas, gasPrice, keystring, accountType,
  password) => {

  var txData = ethereum.call("sendTokenData")(
    sourceToken, sourceAmount, destAddress)
  const txParams = {
    from:account,
    nonce: nonce,
    gasPrice: gasPrice,
    gasLimit: gas,
    to: sourceToken,
    value: '0x0', //这个地方是不是错误的？
    data: txData,
    // EIP 155 chainId - mainnet: 1, ropsten: 3
    chainId: BLOCKCHAIN_INFO.networkId
  }
  return { txParams, keystring, password }
}
```

sendEtherFromAccount发送以太币：

直接从将传入的参数进行了组装后返回，返回的是`{ txParams, keystring, password }`的形式

sendTokenFromAccount发送其他太币：
调用的是

```
var txData = ethereum.call("sendTokenData")(
    sourceToken, sourceAmount, destAddress)
```

方法来获得txData。

然后同样也是组成了{ txParams, keystring, password }进行返回。不同的是，txParams中所包含的字段数量是不一样的。

ethereum: 是一个EthereumService类的实例。

EthereumService类提供了一个call方法：

```js
call(fn) {
    return this.currentProvider[fn].bind(this.currentProvider)
}
```

执行的是this.currentProvider上的方法，并且指定执行时this为this.currentProvider。

this.currentProvider是HttpEthereumProvider类 或者 WebsocketEthereumProvider类的实例，而HttpEthereumProvider类 或者 WebsocketEthereumProvider类都扩展自BaseEthereumProvider类，所以call方法最后应该可以访问 BaseEthereumProvider类 以及 HttpEthereumProvider类 或者 WebsocketEthereumProvider类中的方法。

sendTokenData就是BaseEthereumProvider类中的方法。

```js
sendTokenData(sourceToken, sourceAmount, destAddress) {
    var tokenContract = this.erc20Contract
    tokenContract.options.address = sourceToken
    return tokenContract.methods.transfer(destAddress, sourceAmount).encodeABI()
}
```

调用的实际上是以发送者的地址为地址的ERC20合约实例的`.transfer(destAddress, sourceAmount).encodeABI()`方法，传入参数是发往的地址和数量。

其中， `this.erc20Contract = new this.rpc.eth.Contract(constants.ERC20)`

```js
import * as ethUtil from 'ethereumjs-util'
import scrypt from 'scryptsy'
import crypto from 'crypto'

function decipherBuffer(decipher, data) {
  return Buffer.concat([decipher.update(data), decipher.final()])
}

export function unlock(input, password, nonStrict) {
    var json = (typeof input === 'object') ? input : JSON.parse(nonStrict ? input.toLowerCase() : input)
    if (json.version !== 3) {
        throw new Error('Not a V3 wallet')
    }
    var derivedKey
    var kdfparams
    if (json.crypto.kdf === 'scrypt') {
        kdfparams = json.crypto.kdfparams
        derivedKey = scrypt(new Buffer(password), new Buffer(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen) 
    } else if (json.crypto.kdf === 'pbkdf2') {
        kdfparams = json.crypto.kdfparams
        if (kdfparams.prf !== 'hmac-sha256') {
            throw new Error('Unsupported parameters to PBKDF2')
        }
        derivedKey = crypto.pbkdf2Sync(new Buffer(password), new Buffer(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256')
    } else {
        throw new Error('Unsupported key derivation scheme')
    }
    var ciphertext = new Buffer(json.crypto.ciphertext, 'hex') //密文
    var mac = ethUtil.sha3(Buffer.concat([derivedKey.slice(16, 32), ciphertext]))
    if (mac.toString('hex') !== json.crypto.mac) {
        throw new Error('Key derivation failed - possibly wrong password')
    }
    var decipher = crypto.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), new Buffer(json.crypto.cipherparams.iv, 'hex')) //译文
    var seed = decipherBuffer(decipher, ciphertext, 'hex')
    while (seed.length < 32) {
        var nullBuff = new Buffer([0x00]);
        seed = Buffer.concat([nullBuff, seed]);
    }
    return seed
}
```

unlock函数在拿到导入的钱包数据后，解析成json对象，根据这个对象的.crypto.kdf字段来决定使用哪种密钥派生函数，

若是scryptsy，拿到json对象中的信息传入scryptsy(一个Scrypt密钥派生函数的JS实现库, https://www.npmjs.com/package/scryptsy)

`scrypt（key，salt，n，r，p，keyLenBytes，[progressCallback]）`

key：key。无论是Buffer或string。

salt：盐。无论是Buffer或string。

n：迭代次数。number（整数）

r：记忆因子。number（整数）

p：并行化因子。number（整数）

keyLenBytes：要返回的字节数。number（整数）

progressCallback：调用每个1000操作的回调。{current, total, percent}作为第一个参数传入progressCallback()。
退货Buffer。

若是pbkdf2，拿到json对象中的信息传入crypto(node.js自带模块）的pbkdf2Sync方法，也是得到priveKey。

得到这些priveKey后，再配合ethereumjs-util库进行一系列处理，最终得到seed。

## 五、fetch的使用

### 使用 fetch 调用接口

fetch 是 JavaScript 的内置 API，可以直接使用，但记得要经过 `babel` 的转换。

```js
getLatestBlock() {
    return new Promise((resolve, rejected) => {
      fetch(BLOCKCHAIN_INFO.history_endpoint + '/getLatestBlock', {
        method: 'GET',
        headers: {
          'Accept': 'application/json, text/plain, */*',
          'Content-Type': 'application/json'
        }
      }).then((response) => {
        return response.json()
      }).then((data) => {
        if (data && typeof data == 'number' && data > 0) {
          resolve(data)
        } else {
          throw ('cannot get lastest block from server')
        }
      })
        .catch((err) => {
          this.rpc.eth.getBlock("latest", false).then((block) => {
            if (block != null) {
              resolve(block.number)
            }
          })
        })
    })
}
```

线上好像是从`api.etherscan.io/api?module=proxy&action=eth_blockNumber&apikey=${apikey}`来获取,
比如 apikey = D8YAEQ3V4THAPDA9YSB1YGA1QY9KAMHY6M。

即从http://api.etherscan.io/api?module=proxy&action=eth_blockNumber&apikey=D8YAEQ3V4THAPDA9YSB1YGA1QY9KAMHY6M来获取。

返回的结果如下：

```json
{ 
    "jsonrpc": "2.0", 
    "id": 83, 
    "result": "0x4b9e30" 
}
```

### 封装一个更通用的 fetch:

```js
const defaultHeaders = {
    'Accept': 'application/json, text/plain, */*',
    'Content-Type': 'application/json'
}

export function fetchRequest(url, params, headers=defaultHeaders, method) {
    return new Promise((resolve, reject) => {
        let obj = {};

        if(method === 'POST'){
            obj.body = params;
        } else {
            if(params != null) {
                let paramsArr = [];

                Object.keys(params).map((item) => {
                    paramsArr.push(`${item}=${params[item]}`)
                })

                if(url.indexOf('?') > -1){
                    url += '&'
                } else {
                    url += '?'
                }

                url += ${paramsArr.join('&')}
            }
        }
        obj.method = method;
        obj.headers = headers;

        fetch(url, obj)
        .then(response => {
            return response.json()
        })
        .then(data => {
            resolve(data)
        })
        .catch(err => {
            reject(err)
        });
    });
}

export function get(url, params, headers=defaultHeaders){
    fetchRequest(url, params, headers, 'Get');
}

export function post(url, data, headers=defaultHeaders){
    fetchRequest(url, data, headers, 'Post');
}
```

## 六、国际化

react-localize-redux

https://ryandrewjohnson.github.io/react-localize-redux/getting-started/

## 七、truffle的使用和智能合约的简单操作

### 使用truffle之前的注意点

`truffle init`之后自带的打包流程比较简陋，需要自己集成webpack。比较可行的方法第一种是找一个集成了truffle和webpack的模版来改。

第二种是直接truffle init之后，把原有的webpack打包的项目拷贝整合进来，修改一些配置。借助"truffle-solidity-loader": "0.0.8"进行整合。完全抛弃truffle那些命令，而使用webpack命令。

提供了合约抽象接口，可以直接通过`var meta = MetaCoin.deployed();`拿到合约对象后，在Javascript中直接操作对应的合约函数。原理是使用了基于web3.js封装的Ether Pudding工具包。简化开发流程。

但是，**目前truffle（包括truffle-contract也是）只支持到web3.js的0.2x版本，与web3.js 1.0-beta并不兼容。**

所以，最终发现truffle在使用web3.js 1.0-beta版的时候核心功能完全不可用。

### 初始化一个truffle项目

npm i -g truffle

mkdir trufflewallet
cd trufflewallet

truffle init

目录结构简单说明如下：

contract/ - Truffle默认的合约文件存放地址。
migrations/ - 存放发布脚本文件
test/ - 用来测试应用和合约的测试文件
truffle.js - Truffle的配置文件

切记不要删除./contract/Migrations.sol合约，它是Truffle用来帮助部署的。

新建一个src文件夹：

src - 你的应用文件运行的默认目录。这里面包括推荐的javascript文件和css样式文件目录，但你可以完全决定如何使用这些目录。


### truffle的网络与测试

- Mainnet-以太坊主网，通常是所有客户端的默认网络。

- Ropsten（https://github.com/ethereum/ropsten） - 以太坊使用工作量证明的主测试网络。这个网络，因为低的计算量，容易遭到DDOS攻击，分片，或者其它问题。垃圾邮件攻击后被暂时放弃，最近才恢复使用。

```
geth --testnet removedb
geth --testnet --fast --bootnodes "enode://20c9ad97c081d63397d7b685a412227a40e23c8bdc6688c6f37e97cfbc22d2b4d1db1510d8f61e6a8866ad7f0e17c02b14182d37ea7c3c8b9c2683aeb6b733a1@52.169.14.227:30303,enode://6ce05930c72abc632c58e2e4324f7c7ea478cec0ed4fa2528982cf34483094e9cbc9216e7aa349691242576d552a2a56aaeae426c5303ded677ce455ba1acd9d@13.84.180.240:30303"
```

- ganache

```
npm install -g ganache-cli
```

待研究：

https://github.com/trufflesuite/ganache-cli/

注：ganache-cli就是原来的testrpc，现在改名成了这个。


### truffle中关于合约的操作

- 引入合约依赖：

`import "./AnotherContract.sol";`

此外也支持其它的引入方式：

http://solidity.readthedocs.io/en/latest/layout-of-source-files.html#importing-other-source-files

- 部署合约：

当你部署一个智能合约，你实际进行的操作是向地址0x0发送了一个交易，使用当前合约内容作为参数。

ETHPM是一个去中心化的智能合约包管理资源库。使用ETHPM，你可以关联或连接到某个著名的合约或库，减少代码重复，尽可能理想的为未来的开发提供好的基础。

这里的这个规范(https://github.com/ethereum/EIPs/issues/190)，详细的说明了相关的信息以及背景。Truffle和Embark均可与之集成，并创造一个愉快的开发体验。（待研究）

- 创建一个简单的智能合约

```js
pragma solidity ^0.4.0;

contract Greeter {
    address creater;
    string greeting;

    function Greeter(string _greeting) public {
        creater = msg.sender;
        greeting = _greeting;
    }

    function greet() public constant returns (string) {
        return greeting;
    }

    function setGreeting(string _newGreeting) public {
        greeting = _newGreeting;
    }

    function kill() public {
        if (msg.sender == creater) {
            selfdestruct(creater); // kills this contract and sends remaining funds back to creator
        }
    }
}
```

- 在线编写和试验合约的IDE: Remix

可以把上述合约放上去编译和运行一下，然后在create输入框中输入"abc"来创建一个合约实例感受一下，注意abc必须带有双引号，否则会报错。

https://ethereum.github.io/browser-solidity/

```bash
truffle migrate
truffle migrate --reset #重置
```

拿上面这个合约在truffle中compile一下。

在migrations目录下新建一个文件：

2_deploy_contract.js

```js
var Greeter = artifacts.require('./Greeter.sol');

module.exports = function(deployer, network){
    deployer.deploy(Greeter, 'abc')
}
```

然后执行

```bash
truffle develop
migrate
```
这会部署到`truffle develop`启动的默认网络上：http://127.0.0.1:9545

或者我们可以部署到指定的网络上，按如下步骤操作：

（1）先安装和运行（ganache-cli）：

```
npm i -g ganache-cli
ganache-cli 
```
这样会在本机启动http://localhost:8545服务。

（2）在truffle.js中配置网络

```js
module.exports = {
    // See <http://truffleframework.com/docs/advanced/configuration>
    // to customize your Truffle configuration!

    networks: {
        live: {
            network_id: 1 // Ethereum public network
            // optional config values
            // host // 默认是localhost
            // port // 默认是8545
            // gas // Gas limit used for deploys. Default is 4712388.
            // gasPrice // Gas price used for deploys. Default is 100000000000 (100 Shannon).
            // from //  From address used during migrations. 如果没有指定，默认是你的以太坊客户端第一个可用帐户。
            // provider: Default web3 provider using host and port options: new Web3.providers.HttpProvider("http://<host>:<port>")
        },
        // morden: {
        //     network_id: 2, // Official Ethereum test network
        //     host: "178.25.19.88", // Random IP for example purposes (do not use)
        //     port: 80
        // },
        staging: {
            network_id: 1337 // custom private network
            // use default rpc settings
        },
        dev: {
            host: "localhost",
            port: "8545",
            network_id: "default",
            gas: 4712388
        }
    }
};
```

(3)执行下列命令来指定部署到哪个网络：

```bash
truffle migrate --network dev
```

这里--network dev所指定的就是上面truffle.js中配置的dev网络。

然后，你可以通过如下命令进入truffle控制台。

```bash
truffle console --network dev
```

不管是`truffle develop`还是`truffle console --network dev`的方式，只是指定的部署网络不同，但功能上还是一致的。
现在，在truffle控制台里面都能够使用web3.js的功能了。

比如：

```bash
web3.eth.accounts   #输出所有帐号
```

除此以外，还有很多其它功能。

```
version     # Truffle v4.0.6 (core: 4.0.6)  Solidity v0.4.19 (solc-js)
networks    # 查看有哪些network可用
test        # 执行测试
```

### 集成进webpack

```
npm i truffle-solidity-loader -D
```

并在webpack的config文件中添加如下关于loader的配置：

```js
{
    test: /\.sol$/,
    loader: require.resolve('truffle-solidity-loader')
},
```

在`resolve.alias`中添加：

`contracts: path.resolve('contracts')`

```js
import Greeter from 'contracts/Greeter.sol';
console.log(Greeter.deployed().setGreeting);
```

现在truffle-solidity-loader好像存在bug，会出现"ReferenceError: artifacts is not defined"的错误，暂时只能通过在migrations文件夹下的每个文件中，都把形如`var Migrations = artifacts.require("./Migrations.sol");`的代码给注释掉。

### 处理无法import src以外目录的异常

这个是因为create-react-app脚手架生成的项目通过ModuleScopePlugin做了限制所导致的，所以正确的做法是把这个插件从配置文件中移除掉。

参见：https://stackoverflow.com/questions/44114436/the-create-react-app-imports-restriction-outside-of-src-directory


### 编译合约的时候报出异常： Truffle mingration: Error: authentication needed: password or unlock 的处理

用ganance-cli作为网络客户端的时候，似乎没有出现这个异常，但是，改成用geth之后，异常就出现了，估计原因应该是ganance-cli是默认解锁了账户的，而geth则没有。

在`geth console`中

`eth.accounts`

["0xedd76ffedac43ed63dceda537787b760bc1c00c1", "0x291b8b0d26dab0f1f4114f5d471c4c5ab2934fee"]

拿到第一个地址：

`personal.unlockAccount('0xedd76ffedac43ed63dceda537787b760bc1c00c1', '123456', 999)`

总结成一条命令就是：

```
personal.unlockAccount(eth.accounts[0], '123456', 99999)
```

部署合约的时候要开始挖矿才能部署成功。

```
miner.start()
```


## 八、生成器函数 和 redux-saga

生成器函数执行到yeild处的时候会暂停。

在生成器函数的函数名前需要加一个*号。

执行第一次`next()`的时候才会执行第一个yield；

执行第二次`next()`的时候会执行第二个yield；

以此类推。

`throw`用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。

```js
function* count(){
	yield 1;
	yield 2;
	yield 3;
}
let c = count().next();

c.next();  //{value: 1, done: false}
c.next();  //{value: 2, done: false}
c.next();  //{value: 3, done: false}
c.next();  //{value: undefined, done: true}
```




